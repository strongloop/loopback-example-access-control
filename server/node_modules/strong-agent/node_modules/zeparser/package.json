{
  "author": {
    "name": "Peter van der Zee",
    "url": "http://qfox.nl/"
  },
  "name": "zeparser",
  "description": "My JavaScript parser",
  "version": "0.0.7",
  "homepage": "https://github.com/qfox/ZeParser/",
  "repository": {
    "type": "git",
    "url": "git://github.com/qfox/ZeParser.git"
  },
  "main": "./ZeParser",
  "engines": {
    "node": "*"
  },
  "dependencies": {},
  "devDependencies": {},
  "readme": "This is a JavaScript parser.\nhttp://github.com/qfox/ZeParser\n(c) Peter van der Zee\nhttp://qfox.nl\n\n\nBenchmark\nhttp://qfox.github.com/ZeParser/benchmark.html\n\nThe Tokenizer is used by the parser. The parser tells the tokenizer whether the next token may be a regular expression or not. Without the parser, the tokenizer will fail if regular expression literals are used in the input.\n\nUsage:\nZeParser.parse(input);\n\nReturns a \"parse tree\" which is a tree of an array of arrays with tokens (regular objects) as leafs. Meta information embedded as properties (of the arrays and the tokens).\n\nZeParser.createParser(input);\n\nReturns a new ZeParser instance which has already parsed the input. Amongst others, the ZeParser instance will have the properties .tree, .wtree and .btree.\n\n.tree is the parse tree mentioned above.\n.wtree (\"white\" tree) is a regular array with all the tokens encountered (including whitespace, line terminators and comments)\n.btree (\"black\" tree) is just like .wtree but without the whitespace, line terminators and comments. This is what the specification would call the \"token stream\".\n\nI'm aware that the naming convention is a bit awkward. It's a tradeoff between short and descriptive. The streams are used quite often in the analysis.\n\nTokens are regular objects with several properties. Amongst them are .tokposw and .tokposw, they correspond with their own position in the .wtree and .btree.\n\nThe parser has two modes for parsing: simple and extended. Simple mode is mainly for just parsing and returning the streams and a simple parse tree. There's not so much meta information here and this mode is mainly built for speed. The other mode has everything required for Zeon to do its job. This mode is toggled by the instance property .ast, which is true by default :)\n\n\nNon-factory example:\n\nvar input = \"foo\";\nvar tree = []; // this should probably be refactored away some day\nvar tokenizer = new Tokenizer(input); // dito\nvar parser = new ZeParser(input, tokenizer, tree);\nparser.parse(); // returns tree..., should never throw errors\nparser.tokenizer.fixValues(); // makes sure all tokens have a .value property\n\n\nHighlighting example:\n\nvar parser = ZeParser.createParser(textarea.value); // textarea.value:input\nparser.tokenizer.fixValues(); // makes sure all tokens have a .value property\nvar wtree = parser.tokenizer.wtree; // all the tokens (\"token stream\", including whitespace)\ntextarea.className = '';\nvar tokenstrings = wtree.map(function(t){\n\tif (t.name == 14) textarea.className = 'error';\n\treturn '<span class=\"t'+t.name+'\">'+(t.name==13?'\\u29e6':(t.name==14?'\\u292c':t.value)).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')+'</span>';\n});\n// the string that would contain highlighted code\n// tokenstrings.join('');\n",
  "readmeFilename": "README",
  "bugs": {
    "url": "https://github.com/qfox/ZeParser/issues"
  },
  "_id": "zeparser@0.0.7",
  "_from": "zeparser@*"
}
